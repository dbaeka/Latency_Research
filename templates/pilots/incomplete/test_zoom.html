<!DOCTYPE html>
<meta charset="utf-8">
<style>


    svg {
        border: 3px solid black;
    }

    .hide {
        display: none;
    }

    button {
        margin-bottom: 10px;
    }

    #sendDataInfo, #batchNumber {
        color: blue;
        font-size: 20px;
        font-weight: bold;
    }

    #timer-container {
        display: none;
    }

    #timer {
        color: red;
    }

    #svg-zoom-container {
        display: flex;
    }
</style>

<div>
    <p>You can drag and zoom in/out the collage to see more images. There may be a delay before some images appear.</p>
    <p>There is a single picture of a dinosaur, possibly in any region of the collage. <b>Find this dinosaur picture</b> within the collage.</p>
    <p><b>Please do not reload the page or hit the back button in the browser window!</b></p>
    <div id="timer-container"><b><span id="timer">0 min 00 seconds</span></b> remaining</div>
    <p>Targets Found: <span id="targetsFound"></span></p>
    <div>
        <span id="sendDataInfo"></span> <span id="batchNumber"></span>
    </div>
    <button id="finish-button">FOUND <span id="answer-number"></span></button>
    <button id="quit-button">FINISH</button>
</div>
<div id="svg-zoom-container">
    <div id="svg-container">
        <svg id="svg-obj" width="1000" height="700"></svg>
        <p id="done-text" class="hide">You have <b> 0 min 0 seconds</b>. Time out. Please click "FINISH".</p>
    </div>
    <div id="zoom_prompt">
        <h2>Zoom Level: <span id="zoomLevel"></span></h2>
        <h3><b>To zoom in, double click the area you want to zoom into.</b></h3>
        <h3><b>To zoom out, right click the area you want to zoom out.</b></h3>
        <h3><b>You can at most zoom to level 5.</b></h3>
    </div>
</div>
<script src="{{ url_for('static',filename='lib/d3/d3.js') }}"></script>
<script src="{{ url_for('static',filename='js/logs.js') }}"></script>
<script>
    d3.selection.prototype.moveToFront = function () {
        return this.each(function () {
            this.parentNode.appendChild(this);
        });
    };
    var log = [];
    var userid = sessionStorage.id;
    //console.log(userid);
    var timer_interval = null;//setInterval(timer, 1000); // Time in milliseconds
    var timer_counter = 10;

    // controlled by zooming level
    var zoom_ratio = [20, 10, 5, 2.5, 1.25]; // corresponding to 40*40, 20*20, 10*10, 5*5, 2.5*2.5
    var zoom_level = 0; //0, 1, 2, 3, 4
    var zoom_value = zoom_ratio[zoom_level];
    var regions = JSON.parse(decodeHtml("{{regions}}"));
    var zoomObject = document.getElementById("zoomLevel");
    zoomObject.innerText = zoom_level + 1;
    var isFirst = true;

    var svg = d3.select("svg"),
        width = +svg.attr("width"),
        height = +svg.attr("height"),
        imwidth = 465 / zoom_value,
        imheight = 349 / zoom_value,
        boxrad = {"x": imwidth, "y": imheight};
    //boxrad = {"x":imwidth/2.0,"y":imheight/2.0};

    svg.append("text")
        .attr("x", 0)
        .attr("y", 100)
        .text("LOADING")
        .attr("font-family", "sans-serif")
        .attr("font-size", "100px")
        .attr("fill", "blue")
        .classed("loadingText", true);
    svg.append("text")
        .attr("x", 0)
        .attr("y", 100 + 80)
        .text("DATA...")
        .attr("font-family", "sans-serif")
        .attr("font-size", "100px")
        .attr("fill", "blue")
        .classed("loadingText", true);
    svg.append("text")
        .attr("x", 0)
        .attr("y", 100 + 80 + 60)
        .text("This may take a few")
        .attr("font-family", "sans-serif")
        .attr("font-size", "60px")
        .attr("fill", "blue")
        .classed("loadingText", true);
    svg.append("text")
        .attr("x", 50)
        .attr("y", 100 + 80 + 60 + 60)
        .text("minutes...")
        .attr("font-family", "sans-serif")
        .attr("font-size", "60px")
        .attr("fill", "blue")
        .classed("loadingText", true);
    var imagesList = [];
    var imagesCache = {};

    var image_positions = JSON.parse(decodeHtml("{{imagesDict}}"));
    var tilesAdded = [];

    //var starting_pos = {"x":{{starting_pos_x}},"y":{{starting_pos_y}}};  //DB: get the value oof starting image in grid
    var starting_pos = {"x": 19, "y": 19};
    // pixel position
    var center_loc = {
        "x": starting_pos.x * imwidth + imwidth / 2.0,
        "y": starting_pos.y * imheight + imheight / 2.0
    };
    //DB: get grid location and multiply by image w&h to get location in points and then add half of image w&h to find center
    //var center_loc = {"x":width/2.0,"y":height/2.0};
    // staging point is very important. For its value, it is actually the center point of some pic
    // but this pic is corresonding to the pic which is in the center of the view
    var staging_loc = {"x": center_loc.x, "y": center_loc.y}; //DB: puts the image directly in the center
    // grid positions
    //var good_pos ={"x":9,"y":0}, bad_pos={"x":9,"y":10};
    // TODO: Change good pos to locations of targets
    var goodps_pos =
    {{good_pos | safe}} // jinja2 syntax
    var badps_pos =
    {{bad_pos | safe}} // jinja2 syntax
    var good_locs = []
    var bad_locs = []
    goodps_pos.forEach(obj => {
        var good_loc = {}
        good_loc["x"] = imwidth * obj["x"] + imwidth / 2.0
        good_loc["y"] = imheight * obj["y"] + imheight / 2.0
        good_locs.push(good_loc)
    })
    badps_pos.forEach(obj => {
        var bad_loc = {}
        bad_loc["x"] = imwidth * obj["x"] + imwidth / 2.0
        bad_loc["y"] = imheight * obj["y"] + imheight / 2.0
        bad_locs.push(bad_loc)
    })


    // DB: get bounding x and y of a box that surrounds the points. Where boxrad here is image size.
    //  TODO: box size might have to be revised to meet the zoom areas and not images. ie. window with divided into 16 pieces
    //  TODO: get boxes for regions
    //var goodBox = {
    //  "minp": {"x": good_loc.x - boxrad.x, "y": good_loc.y - boxrad.y},
    //"maxp": {"x": good_loc.x + boxrad.x, "y": good_loc.y + boxrad.y}
    //};
    //var badBox = {
    //  "minp": {"x": bad_loc.x - boxrad.x, "y": bad_loc.y - boxrad.y},
    //"maxp": {"x": bad_loc.x + boxrad.x, "y": bad_loc.y + boxrad.y}
    //};

    var timeouts = []
    var sample_pos = 100;

    // controlled by traverseImagePositions
    var positions = {};
    var global_max = {};
    var pixel_positions = {};
    // ensures that ordering is consistent when adding tiles
    var pixelOrdersX = [];
    var pixelOrdersY = [];

    //controlled by click/drag handlers
    var targetsFound = 0;
    var targetsFoundObj = document.getElementById("targetsFound");
    var targetsFoundList = [];
    targetsFoundObj.innerText = targetsFound;
    var finish_button_obj = document.getElementById("finish-button");
    var quit_button_obj = document.getElementById("quit-button");
    quit_button_obj.onclick = function () {
        if (confirm("You are leaving the collage page. To stay on this page and continue the task, hit Cancel. Click OK to submit your answers and move on to the final survey!")) {
            logStudyEndButtonClick();
            logTargetsFoundList();
            var sendDataInfoObj = document.getElementById("sendDataInfo");
            var batchNumberObj = document.getElementById("batchNumber");
            var url = "{{url_for('storeLogDataInBatches')}}";
            sendDataInfoObj.innerText = "Sending log data...";

            sendInBatches(userid, log, batchNumberObj, url, function () {
                batchNumberObj.innerText = "";
                sendDataInfoObj.innerText = "Done sending log data! Moving to next page...";
                window.location = "{{url_for('renderPostTest')}}";
            });
        }
    };

    // did the user already find this target?
    function alreadyFound(curr_pos) {
        for (var i = 0; i < targetsFoundList.length; i++) {
            var pos = targetsFoundList[i];
            if (curr_pos.x === pos.x && curr_pos.y === pos.y) {
                return true;
            }
        }
        return false;
    }

    function isFound(curr_pos_x, curr_pos_y, goodps_pos, badps_pos) {
        flag = false;
        goodps_pos.forEach(good_pos => {
            console.log(good_pos)
            if (good_pos["x"] === curr_pos_x && good_pos["y"] === curr_pos_y) {
                flag = true;
            }
        })
        badps_pos.forEach(bad_pos => {
            if (bad_pos["x"] === curr_pos_x && bad_pos["y"] === curr_pos_y) {
                flag = true;
            }
        })
        return flag;
    }

    // the button is the "FOUND" button
    finish_button_obj.onclick = function () {
        // we do not perform check if the users actually find more than 2 targets
        if (targetsFoundList.length === 1) {
            alert("You have already marked the target pictures as found. You have completed the task. Please click Finish to exit this experiment.");
            return;
        }
        // check if the target is really in the center of the view and the zoom level is 5
        // calculate the index of current centered pic
        var curr_pos = {"x": Math.floor(staging_loc.x / imwidth), "y": Math.floor(staging_loc.y / imheight)};
        if (zoom_level === 4 &&
            (isFound(curr_pos.x, curr_pos.y, goodps_pos, badps_pos))) {
            if (alreadyFound(curr_pos)) {
                alert("You have already marked this target picture as found. Try to find the other target picture.");
            } else {
                logFoundButtonClick();
                targetsFound++;
                targetsFoundList.push(curr_pos);
                targetsFoundObj.innerText = targetsFound;
                if (targetsFound >= 2) {
                    alert("Correct! You have found more than 1 targets. You are done with this task. Please click Finish button.");
                } else {
                    alert("Correct, you found the target picture! You are done with this task.");
                    alert("Please click Finish button to exit the experiment.")
                }
            }
        } else {
            alert("The target picture is not in view or you didn't zoom into the biggest level. Make sure the target picture is in the center of the collage window and you zoom into level 5.");
        }
    };
    // for tracking movement
    var svg_obj = document.getElementById("svg-obj");
    var tileContainer = svg.append("g");
    var overlay = svg.append("rect")
        .attr("width", +svg.attr("width"))
        .attr("height", +svg.attr("height"))
        .style("fill", "#000000")
        .style("opacity", 0)
        .attr("class", "pan-rect");

    var prev = {};// = {"x":0,"y":0};
    var diff = {"x": 0, "y": 0};
    var prevDragStart = {"x": null, "y": null}; // used to pair drag start with drag end
    var prevStagingLoc = {"x": null, "y": null}; // used to pair drag start with drag end
    overlay.call(d3.drag()
        .on("start", function () {
            //if(click_flag) return;
            // get current mouse location
            var coords = d3.mouse(overlay.node());
            logDragStart();
            prevDragStart.x = coords[0];
            prevDragStart.y = coords[1];
            prevStagingLoc.x = staging_loc.x;
            prevStagingLoc.y = staging_loc.y;

            prev.x = coords[0];
            prev.y = coords[1];
            logStagingLoc();
        })
        .on("drag", function () {
            //if(click_flag) return;
            logDragMid();
            updatePrev();
            logStagingLoc();
        })
        .on("end", function () {
            //if(click_flag) return;
            logDragEnd();
            updatePrev();
            removeOffscreenTiles();
            addPreviouslyHiddenTiles(sample_pos);
            logStagingLoc();
            //console.log("staging_loc.x",staging_loc.x,"staging_loc.y",staging_loc.y);
        })
    );
    // DB: when user double clicks to zoom in
    overlay
        .on("dblclick", function (d) {
            isFirst = false;
            var coords = d3.mouse(overlay.node());
            if (zoom_level < 4) {
                var diff_x = coords[0] - width / 2;
                var diff_y = coords[1] - height / 2;
                staging_loc.x += diff_x;
                staging_loc.y += diff_y;
                // find the new starting point according to the click
                var current_pos = {"x": Math.floor(staging_loc.x / imwidth), "y": Math.floor(staging_loc.y / imheight)};
                zoom_level += 1;
                zoom_value = zoom_ratio[zoom_level];
                imwidth = 465 / zoom_value;
                imheight = 349 / zoom_value;
                //calcluate the new staging value based on new imwidth and imheight
                center_loc = {
                    "x": current_pos.x * imwidth + imwidth / 2.0,
                    "y": current_pos.y * imheight + imheight / 2.0
                };
                staging_loc = {"x": center_loc.x, "y": center_loc.y};
                tilesAdded = [];
                traverseImagePositions(sample_pos, isFirst);
                zoomObject.innerText = zoom_level + 1;
                logZoomIn();
                logStagingLoc()
            }
        })
        // DB: zoom out function
        .on("contextmenu", function (d, i) {
            d3.event.preventDefault();
            var coords = d3.mouse(overlay.node());
            if (zoom_level > 0) {
                var diff_x = coords[0] - width / 2;
                var diff_y = coords[1] - height / 2;
                staging_loc.x += diff_x;
                staging_loc.y += diff_y;
                // find the new starting point according to the click
                var current_pos = {"x": Math.floor(staging_loc.x / imwidth), "y": Math.floor(staging_loc.y / imheight)};
                zoom_level -= 1;
                zoom_value = zoom_ratio[zoom_level];
                imwidth = 465 / zoom_value;
                imheight = 349 / zoom_value;
                //calcluate the new staging value based on new imwidth and imheight
                center_loc = {
                    "x": current_pos.x * imwidth + imwidth / 2.0,
                    "y": current_pos.y * imheight + imheight / 2.0
                };
                staging_loc = {"x": center_loc.x, "y": center_loc.y};
                tilesAdded = [];

                traverseImagePositions(sample_pos, isFirst);
                zoomObject.innerText = zoom_level + 1;
                logZoomOut();
                logStagingLoc()
            }

        });
    sendGetRequest({userid: sessionStorage.id, page: "puzzle"}, "{{url_for('logAccess')}}", function () {
    });


    //////////////////////////////////////////////////////
    ////// DELAYS PART///////////////
    ////////////////////////////////////////////////////
    //DB: Delays part

    positions = traverseImagePositions(sample_pos, isFirst);

    //preload the images in the collage
    function preloadImages() {
        var unloaded = imagesList.length;
        //console.log("unloaded",unloaded);
        for (var i = 0; i < imagesList.length; i++) {
            preloadImage(imagesList[i], function () {
                unloaded--;
                if (unloaded === 0) {
                    console.log("done preloading");
                    init(); // continue with the rest of the process
                }
                //console.log(unloaded);
            });
        }
    };

    // preload the image at the given url
    function preloadImage(url, callback) {
        // already cached
        if (imagesCache.hasOwnProperty(url)) {
            callback();
            return;
        }
        try {
            var _img = new Image();
            _img.onload = callback;
            _img.src = url;
            imagesCache[url] = _img;
            //console.log("loaded image",url);
        } catch (e) {
            console.log("failed to load image", url);
        }
    };

    // used to identify all the positions in the image_positions object
    function traverseImagePositions(sample, isFirst) {
        pixel_positions = {"x": {}};
        pixelOrdersX = [];
        pixelOrdersY = [];
        var positions = [];
        for (var xpos in image_positions.x) {
            if (image_positions.x.hasOwnProperty(xpos)) {
                var pxpos = xpos * imwidth;
                if (!("x" in global_max) || global_max.x < pxpos) {
                    global_max.x = pxpos;
                }
                if (!(pxpos in pixel_positions.x)) {
                    pixel_positions.x[pxpos] = {"y": {}};
                }
                pixelOrdersX.push(pxpos);
                var tempPixelOrdersY = [];
                for (var ypos in image_positions.x[xpos].y) {
                    if (image_positions.x[xpos].y.hasOwnProperty(ypos)) {
                        var pypos = ypos * imheight;
                        if (!("y" in global_max) || global_max.y < pypos) {
                            global_max.y = pypos;
                        }
                        if (!(pypos in pixel_positions.x[pxpos].y)) {
                            pixel_positions.x[pxpos].y[pypos] = {
                                "sample": image_positions.x[xpos].y[ypos].sample,
                                "delay": image_positions.x[xpos].y[ypos].delay
                            };
                        }
                        //imagesList.push("{{url_for('serveImage',collection='500-375')}}?image_name="+image_positions.x[xpos].y[ypos].sample[sample_pos]);
                        imagesList.push("{{url_for('serveImage',collection='balanced-500-375')}}?image_name=" + image_positions.x[xpos].y[ypos].sample[sample_pos]);
                        tempPixelOrdersY.push(pypos);
                        // only add if it's in the initial viewport
                        //positions.push({"x":xpos*imwidth,"y":ypos*imheight,"sample":image_positions.x[xpos].y[ypos].sample[sample]});
                        var temp = {
                            "x": xpos * imwidth - staging_loc.x + width / 2.0,
                            "y": ypos * imheight - staging_loc.y + height / 2.0,
                            "sample": image_positions.x[xpos].y[ypos].sample[sample],
                            "delay": image_positions.x[xpos].y[ypos].delay
                        };
                        var temp2 = {
                            "staging_loc": staging_loc, "pxpos": parseFloat(pxpos), "pypos": parseFloat(pypos),
                            "x": parseFloat(pxpos) - parseFloat(staging_loc.x) + width / 2.0,
                            "y": parseFloat(pypos) - parseFloat(staging_loc.y) + height / 2.0,
                            "sample": image_positions.x[xpos].y[ypos].sample[sample],
                            "delay": image_positions.x[xpos].y[ypos].delay
                        };
                        //if(tileWithinBox({"x":staging_loc.x-width/2.0+1,"y":staging_loc.y-height/2.0+1},
                        //{"x":staging_loc.x+width/2.0-1,"y":staging_loc.y+height/2.0-1},temp,imwidth,imheight)) {
                        if (tileWithinBox({"x": 0, "y": 0}, {"x": width, "y": height}, temp, imwidth, imheight)) {
                            //positions.push(temp);
                            positions.push(temp2);
                        }
                    }
                }
                pixelOrdersY.push(tempPixelOrdersY); // for each pxpos, should have an array of pypos values
            }
        }
        if (isFirst) {
            preloadImages();
        } else {
            reinit(positions);
        }
        return positions;
    };

    function tileWithinBox(minp, maxp, p, w, h) {
        return polygonWithinBox(minp, maxp, [p, {"x": p.x + w, "y": p.y + h}, {"x": p.x, "y": p.y + h}, {
            "x": p.x + w,
            "y": p.y
        }]);
    };

    // minp = minimum x and y values for the box
    // maxp = maximum x and y values for the box
    // poly = all outside points for the polygon
    function polygonWithinBox(minp, maxp, poly) {
        for (var i = 0; i < poly.length; i++) {
            var p = poly[i];
            if (p.x >= minp.x && p.y >= minp.y && p.x <= maxp.x && p.y <= maxp.y) {
                return true;
            }
        }
        return false;
    };

    function decodeHtml(html) {
        var txt = document.createElement("textarea");
        txt.innerHTML = html;
        return txt.value;
    };

    function updatePrev() {
        var coords = d3.mouse(overlay.node());
        diff = {"x": coords[0] - prev.x, "y": coords[1] - prev.y};
        prev.x = coords[0];
        prev.y = coords[1];
        staging_loc.x -= diff.x;
        staging_loc.y -= diff.y;
        tileContainer.selectAll(".tiles").attr("x", function (d) {
            d.x = d.x + diff.x;
            return d.x;
        })
            .attr("y", function (d) {
                d.y = d.y + diff.y;
                return d.y;
            });

        // update background
        var bgx = parseFloat(svg.select("#background-rect").attr("x"));
        var bgy = parseFloat(svg.select("#background-rect").attr("y"));
        svg.select("#background-rect").attr("x", bgx + diff.x)
            .attr("y", bgy + diff.y);
        //svg.selectAll(".target").attr("cx",function(d){d.x = d.x+diff.x;return d.x;})
        //  .attr("cy",function(d){d.y = d.y+diff.y;return d.y;});
    };

    function removeOffscreenTiles() {
        tileContainer.selectAll(".tiles").filter(function (d) {
            return d.x > (width) || d.x < -imwidth || d.y < -imheight || d.y > (height);
        }).each(function (d, i) {
            logTileRemoval(d);
        }).remove();
    };


    function addPreviouslyHiddenTiles(sample) {
        // note that at this time, staging_loc is the endpoint after dragging, center_loc is
        // initially the starting point
        var d = {
            "x": staging_loc.x - center_loc.x,
            "y": staging_loc.y - center_loc.y
        };
        var xscan, yscan;
        // if pan right, add tiles from the left
        if (d.x < 0) {
            xscan = [staging_loc.x - width / 2.0, center_loc.x - width / 2.0];
        }
        // if pan left, add tiles from the right
        else {
            xscan = [center_loc.x + width / 2.0, staging_loc.x + width / 2.0];
        }
        // if pan down, add tiles from the top
        if (d.y < 0) {
            yscan = [staging_loc.y - height / 2.0, center_loc.y - height / 2.0];
        }
        // if pan up, add tiles from the bottom
        else {
            yscan = [center_loc.y + height / 2.0, staging_loc.y + height / 2.0];
        }

        getTilesWithinBounds(d, xscan, yscan, sample);
        // update center
        center_loc.x = staging_loc.x;
        center_loc.y = staging_loc.y;
    };

    function getTilesWithinBounds(d, xscan, yscan, sample) {
        var add_positions = [];
        var xrange = [staging_loc.x - width / 2.0, staging_loc.x + width / 2.0];
        var yrange = [staging_loc.y - height / 2.0, staging_loc.y + height / 2.0];
        var pxposKeys = pixelOrdersX;
        for (var i = 0; i < pxposKeys.length; i++) {
            var pxpos = pxposKeys[i];
            if (!pixel_positions.x.hasOwnProperty(pxpos)) continue;
            var pyposKeys = pixelOrdersY[i];
            pxpos = parseFloat(pxpos);
            for (var j = 0; j < pyposKeys.length; j++) {
                var pypos = pyposKeys[j];
                if (!pixel_positions.x[pxpos].y.hasOwnProperty(pypos)) continue;
                pypos = parseFloat(pypos);
                if (tilesAdded.filter(function (d) {
                    return d.pxpos === pxpos && d.pypos === pypos
                }).length > 0) {
                    //console.log("found duplicate, skipping");
                    continue;
                }
                // is it in the update range?
                if ((d.x >= 0) && (pxpos) >= xscan[0] && (pxpos) < xscan[1] &&
                    (pypos >= yrange[0] && pypos < yrange[1] || (pypos + imheight - 1) >= yrange[0] && (pypos + imheight - 1) < yrange[1]) ||
                    (d.y < 0) && (pypos + imheight - 1) >= yscan[0] && (pypos + imheight - 1) < yscan[1] &&
                    (pxpos >= xrange[0] && pxpos < xrange[1] || (pxpos + imwidth - 1) >= xrange[0] && (pxpos + imwidth - 1) < xrange[1]) ||
                    // need to check both ends of the yrange
                    (d.x < 0) && (pxpos + imwidth - 1) >= xscan[0] && (pxpos + imwidth - 1) < xscan[1] &&
                    (pypos >= yrange[0] && pypos < yrange[1] || (pypos + imheight - 1) >= yrange[0] && (pypos + imheight - 1) < yrange[1]) ||
                    // need to check both ends of the xrange
                    (d.y >= 0) && (pypos) >= yscan[0] && (pypos) < yscan[1] &&
                    (pxpos >= xrange[0] && pxpos < xrange[1] || (pxpos + imwidth - 1) >= xrange[0] && (pxpos + imwidth - 1) < xrange[1])) {

                    add_positions.push({
                        "staging_loc": staging_loc, "pxpos": parseFloat(pxpos), "pypos": parseFloat(pypos),
                        "x": parseFloat(pxpos) - parseFloat(staging_loc.x) + width / 2.0,
                        "y": parseFloat(pypos) - parseFloat(staging_loc.y) + height / 2.0,
                        "sample": pixel_positions.x[pxpos].y[pypos].sample[sample],
                        "delay": pixel_positions.x[pxpos].y[pypos].delay
                    });
                }
            }
        }
        appendTilesUsingTargets(add_positions);
    };

    // given the location of the "good" target, and the "bad" target
    // and the tiles to add, set the appropriate delays for the tiles
    // with respect to these targets
    function appendTilesUsingTargets(tilePositions, isFirst = false) {
        //console.log("tilePositions",tilePositions)

        // append tiles with delays
        for (var i = 0; i < tilePositions.length; i++) {
            appendTileWithDelay(tilePositions[i], isFirst);
        }
    }

    function appendTileWithDelay(d, isFirst) {
        var now = Date.now();
        var delay_length = isFirst ? 0 : (zoom_level === 0) ? 0 : d["delay"];
        //console.log(delay_length)
        tilesAdded.push(d);
        timeout = setTimeout(function () {
            appendTile(d, now, delay_length);
        }, delay_length);
        timeouts.push(timeout)
    };


    function appendTile(d, start_time, delay_length) {
        d.x = d.pxpos - staging_loc.x + width / 2.0;
        d.y = d.pypos - staging_loc.y + height / 2.0;
        //console.log(d);
        tileContainer.selectAll(".dummy")
            .data([d])
            .enter().append("svg:image")
        //.attr("xlink:href", "../static/img/test_images/"+d.sample)
        //.attr("xlink:href", "../adjusted_birds/"+d.sample)
        //.attr("xlink:href", server_url+"images/500-375/"+d.sample)
        //.attr("xlink:href", "{{url_for('serveImage',collection='500-375')}}?image_name="+d.sample)
        //.attr("xlink:href", imagesCache["{{url_for('serveImage',collection='500-375')}}?image_name="+d.sample].src)
            .attr("xlink:href", imagesCache["{{url_for('serveImage',collection='balanced-500-375')}}?image_name=" + d.sample].src)
            .attr("x", d.x)
            .attr("y", d.y)
            .attr("width", imwidth)
            .attr("height", imheight)
            .classed("tiles", true);
        var end_time = Date.now();
        logTileAddition(d, delay_length, start_time, end_time);

        // remove this tile from the tilesAdded list
        var i = 0;
        for (; i < tilesAdded.length; i++) {
            if (tilesAdded[i].pxpos === d.pxpos && tilesAdded[i].pypos === d.pypos) {
                break;
            }
        }
        if (i < tilesAdded.length) {
            tilesAdded.splice(i, 1);
        }
        //console.log(d,start_time,end_time,end_time-start_time,delay_length);
        tileContainer.selectAll(".foundText").moveToFront();
    };

    function logStudyEndButtonClick() {
        //var newEntry = {"userid":userid,"recordType":"studyEndButtonClick","svgwidth":width,"svgheight":height,"stagingLoc":{"x":staging_loc.x,"y":staging_loc.y},
        //  "imwidth":imwidth,"imheight":imheight,
        var newEntry = {
            "recordType": "studyEndButtonClick", "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y},
            "timestamp": getTimestamp()
        };
        log.push(newEntry);
    };

    function logTargetsFoundList() {
        var newEntry = {
            "recordType": "targetsFoundList", "targetsFoundList": targetsFoundList, "targetsFound": targetsFound,
            "timestamp": getTimestamp()
        };
        log.push(newEntry);
    };


    function logDragStart() {
        //console.log("log drag start")
        var coords = d3.mouse(overlay.node());
        //console.log(coords);
        //console.log("-----")
        //var newEntry = {"userid":userid,"recordType":"dragStart","mousex":coords[0],"mousey":coords[1],"timestamp":getTimestamp(),
        var newEntry = {
            "recordType": "dragStart", "mousex": coords[0], "mousey": coords[1], "timestamp": getTimestamp(),
            "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y}
        };
        //console.log(newEntry);
        log.push(newEntry);
    };

    function logZoomIn() {
        var coords = d3.mouse(overlay.node());
        var newEntry = {
            "recordType": "zoomIn",
            "mousex": coords[0],
            "mousey": coords[1],
            "timestamp": getTimestamp(),
            "zoomLevel": zoom_level,
            "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y}
        };
        log.push(newEntry);
    }

    function logZoomOut() {
        var coords = d3.mouse(overlay.node());
        var newEntry = {
            "recordType": "zoomOut",
            "mousex": coords[0],
            "mousey": coords[1],
            "timestamp": getTimestamp(),
            "zoomLevel": zoom_level,
            "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y}
        };
        log.push(newEntry);
    }

    function logDragEnd() {
        //console.log("log drag end")
        var coords = d3.mouse(overlay.node());
        //console.log(coords);
        //console.log("-----")
        //var newEntry = {"userid":userid,"recordType":"dragEnd","mousex":coords[0],"mousey":coords[1],
        var newEntry = {
            "recordType": "dragEnd", "mousex": coords[0], "mousey": coords[1],
            "timestamp": getTimestamp(), "prevDragStart": {"x": prevDragStart.x, "y": prevDragStart.y},
            "prevStagingLoc": {"x": prevStagingLoc.x, "y": prevStagingLoc.y},
            "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y}
        };
        //console.log(newEntry);
        log.push(newEntry);
    };

    function logDragMid() {
        //console.log("log drag mid")
        var coords = d3.mouse(overlay.node());
        //console.log(coords);
        //console.log("-----")
        //var newEntry = {"userid":userid,"recordType":"dragMid","mousex":coords[0],"mousey":coords[1],"timestamp":getTimestamp()};
        var newEntry = {"recordType": "dragMid", "mousex": coords[0], "mousey": coords[1], "timestamp": getTimestamp()};
        //console.log(newEntry);
        log.push(newEntry);
    };

    function logStagingLoc() {
        //var newEntry = {"userid":userid,"recordType":"visPosition","svgwidth":width,"svgheight":height,
        var newEntry = {
            "recordType": "visPosition",
            "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y}, "timestamp": getTimestamp()
            //"imwidth":imwidth,"imheight":imheight,
        };
        //console.log(newEntry);
        log.push(newEntry);
    };

    function logTileRemoval(toRemove) {
        if (toRemove.length === 0) return;
        // everything you need to reverse-engineer the original position:
        // orig.x = curr.x + staging.x - width/2.0
        // orig.y = curr.y + staging.y - height/2.0
        //var newEntry = {"userid":userid,"recordType":"tileRemoval","svgwidth":width,"svgheight":height,"stagingLoc":{"x":staging_loc.x,"y":staging_loc.y},
        var newEntry = {
            "recordType": "tileRemoval", "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y},
            "toRemove": toRemove, "timestamp": getTimestamp()
        };
        //"imwidth":imwidth,"imheight":imheight};
        //console.log(newEntry);
        log.push(newEntry);
    };

    function logTileAddition(toAdd, delay, startTime, endTime) {
        if (toAdd.length === 0) return;
        // everything you need to reverse-engineer the original position:
        // orig.x = curr.x + staging.x - width/2.0
        // orig.y = curr.y + staging.y - height/2.0
        //var newEntry = {"userid":userid,"recordType":"tileAddition","svgwidth":width,"svgheight":height,"stagingLoc":{"x":staging_loc.x,"y":staging_loc.y},
        //  "toAdd":toAdd,"timestamp":getTimestamp(),"delay":delay,"startTime":startTime,"endTime":endTime,"imwidth":imwidth,"imheight":imheight};
        var newEntry = {
            "recordType": "tileAddition", "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y},
            "toAdd": toAdd, "timestamp": getTimestamp(), "delay": delay, "startTime": startTime, "endTime": endTime
        };
        //console.log(newEntry);
        log.push(newEntry);
    };

    function buildParams(dat) {
        var parsedParams = [];
        for (var key in dat) {
            var val = dat[key];
            if ((val == null) || (typeof (val) === 'undefined')) {
                val = "";
            }
            var p = encodeURIComponent(key) + "=";
            if ((typeof val === 'string') || isNumber(val) || (typeof val === 'boolean')) {
                p += encodeURIComponent(val);
            } else { // is some object
                //console.log("is object");
                p += encodeURIComponent(JSON.stringify(val));
            }
            //parsedParams.push(encodeURIComponent(key) + "=" + encodeURIComponent(val));
            //console.log(["param",key,JSON.stringify(val),encodeURIComponent(JSON.stringify(val))]);
            parsedParams.push(p);
        }
        return parsedParams.join("&");
    };

    function sendRequestHelper(dat, requestType, responseType, url, callback, errorCallback) {
        var paramsString = buildParams(dat);
        var newUrl = (requestType === "GET") ? url + "?" + paramsString : url;
        //console.log(newUrl);
        var oReq = new XMLHttpRequest();
        oReq.open(requestType, newUrl, true); // async = true
        oReq.responseType = responseType;
        oReq.onload = function (oEvent) {
            if (oReq.readyState == 4) { // state = DONE
                var reqStatus = oReq.status;
                if (reqStatus == 200) { // status = OK
                    var data = oReq.response;
                    if (responseType === "") { // assume we want the DOM string instead
                        data = oReq.responseText;
                    }
                    callback && callback(data);
                } else {
                    if (errorCallback) { // if error handling is provided
                        errorCallback(reqStatus);
                    } else { // just call the callback anyway
                        callback && callback(null);
                    }
                }
            }
        };

        if (requestType === "GET") {
            oReq.send();
        } else { // post method
            oReq.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            oReq.send(paramsString);
        }
    };

     function sendGetRequestHelper(dat, responseType, url, callback, errorCallback) {
        sendRequestHelper(dat, "GET", responseType, url, callback, errorCallback);
    };

    function sendPostRequestHelper(dat, responseType, url, callback, errorCallback) {
        sendRequestHelper(dat, "POST", responseType, url, callback, errorCallback);
    };

    function sendGetRequest(dat, url, callback) {
        sendGetRequestHelper(dat, "", url, callback);
    };

    function sendPostRequest(dat, url, callback) {
        sendPostRequestHelper(dat, "", url, callback);
    };

    function getTimestamp() {
        return new Date().getTime()
    };

    function init() {
        var parameters = {
            "recordType": "initialState",
            "userid": userid,
            "imwidth": imwidth,
            "imheight": imheight,
            "regions": regions,
            "svgwidth": width,
            "svgheight": height,
            "zoom_level": zoom_level,
            "starting_pos": starting_pos,
            "center_loc": {"x": center_loc.x, "y": center_loc.y}, // starting location
            "goodps_pos": goodps_pos,
            "good_locs": good_locs,
            "badps_pos": badps_pos,
            "bad_locs": bad_locs,
            "boxrad": boxrad,
            "image_positions": image_positions, // the images that were in the collage, and their positions
            "timestamp": getTimestamp(),
            "pixelOrdersX": pixelOrdersX,
            "pixelOrdersY": pixelOrdersY,
        };
        log.push(parameters);// log the starting state


        svg.insert("rect", ":first-child")
            .attr("x", 0 - staging_loc.x + width / 2.0)
            .attr("y", 0 - staging_loc.y + height / 2.0)
            .attr("width", imwidth * pixelOrdersX.length)
            .attr("height", imheight * pixelOrdersY[0].length)
            .attr("fill", "#bfbfbf")
            .attr("stroke", "black")
            .attr("stroke-width", 3)
            .attr("stroke-dasharray", "5,10,5")
            .attr("id", "background-rect");

        svg.selectAll(".loadingText").remove();
        appendTilesUsingTargets(positions, true);
    };

    function reinit(positions) {
        var parameters = {
            "recordType": "reinitialState",
            "userid": userid,
            "imwidth": imwidth,
            "imheight": imheight,
            "svgwidth": width,
            "regions": regions,
            "svgheight": height,
            "zoom_level": zoom_level,
            "starting_pos": starting_pos,
            "center_loc": {"x": center_loc.x, "y": center_loc.y}, // starting location
            "goodps_pos": goodps_pos,
            "good_locs": good_locs,
            "badps_pos": badps_pos,
            "bad_locs": bad_locs,
            "boxrad": boxrad,
            "image_positions": image_positions, // the images that were in the collage, and their positions
            "timestamp": getTimestamp(),
            "pixelOrdersX": pixelOrdersX,
            "pixelOrdersY": pixelOrdersY,
        };
        log.push(parameters);// log the starting state
        svg.select("#background-rect").remove();
        tileContainer.selectAll(".tiles").remove();
        svg.insert("rect", ":first-child")
            .attr("x", 0 - staging_loc.x + width / 2.0)
            .attr("y", 0 - staging_loc.y + height / 2.0)
            .attr("width", imwidth * pixelOrdersX.length)
            .attr("height", imheight * pixelOrdersY[0].length)
            .attr("fill", "#bfbfbf")
            .attr("stroke", "black")
            .attr("stroke-width", 3)
            .attr("stroke-dasharray", "5,10,5")
            .attr("id", "background-rect");

        for (timeout of timeouts)
            clearTimeout(timeout);
        timeouts = [];
        appendTilesUsingTargets(positions, false);
    }

    function logFoundButtonClick() {
        var newEntry = {
            "recordType": "foundButtonClick", "stagingLoc": {"x": staging_loc.x, "y": staging_loc.y},
            "timestamp": getTimestamp()
        };
        log.push(newEntry);
    };
</script>
